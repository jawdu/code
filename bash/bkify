#!/bin/bash

# take a text, turn it into mock-Bernard / mock-Krasznahorkai. Try a js one as well?
# so e.g. eliminate full stops. dash or comma or semi colons, or ellipsis??
# another idea: add few repeats of texts: e.g. sequence 'and wordw rodw words,'

fileIn="$1"
fileOut=$(echo "${fileIn%.*}.bkify.out.txt")

# remove newlines. tr better than sed, people say. also creates output file
tr -d '\n' < $fileIn > $fileOut

# copy 1st character [capital] and store it for later...
c1=$(head -c 1 $fileOut)

# de-capitalise. tr can't modify file in-place
tr '[:upper:]' '[:lower:]' <$fileOut >tfile && mv tfile $fileOut

# replace 1st character with stored capital
sed -i "0,/./s/^./$c1/g" "$fileOut"

# at the moment - just add comma. need to deal with both line break & spaces -> extra spaces
sed -i "s/\([a-z]*\)\+\.\+/\1\, /g" "$fileOut"

# eliminate any extras spaces that creep in
tr -s ' ' <$fileOut >tfile && mv tfile $fileOut

# change some commas to other things. nc: number of commas.
nc=$(tr -cd , < $fileOut | wc -c)
p=0

while [ $p -lt $nc ]; do
    # in range 1-100 (random enough for this use)
    k=$((RANDOM % 100))

    if [ "$k" -lt 4 ]; then
        sed -i "s/\,/\;/$k" "$fileOut"
    elif [ "$k" -lt 8 ]; then
        sed -i "s/\,/\:/$k" "$fileOut"
    elif [ "$k" -lt 12 ]; then
        sed -i "s/\,/\ -/$k" "$fileOut"
    elif [ "$k" -lt 16 ]; then
        sed -i "s/\,/\.\.\./$k" "$fileOut"
    fi
    # increment $p regardless
    p=$((p+1))
done 

echo "finished, output text is $fileOut"

