#!/bin/bash

# take a text, turn it into mock-Bernard / mock-Krasznahorkai. Try a js one as well?
# so e.g. eliminate full stops. dash or comma or semi colons, or ellipsis??
# another idea: add few repeats of texts: e.g. sequence 'and wordw rodw words,'

fileIn="$1"
fileOut=$(echo "${fileIn%.*}.bkify.out.txt")

# remove newlines. tr better than sed, people say. also creates output file
tr -d '\n' < $fileIn > $fileOut

# copy 1st character [capital] and store it for later...
c1=$(head -c 1 $fileOut)

# de-capitalise. tr can't modify file in-place
tr '[:upper:]' '[:lower:]' <$fileOut >tfile && mv tfile $fileOut

# replace 1st character with stored capital
sed -i "0,/./s/^./$c1/g" "$fileOut"

# ^ overcome by using '[a-z]. could also then use that to create rules - for er, ing, etc...?
# or set up about 5 different schemes, randomly choose one

# at the moment - just add comma.
#sed -i "s/\([a-z]*\)\+\. /\1\, /g" "$fileOut"
sed -i "s/\([a-z]*\)\+\.\+/\1\, /g" "$fileOut"

# eliminate any extras spaces that creep in
tr -s ' ' <$fileOut >tfile && mv tfile $fileOut

echo "finished, output text is $fileOut"

